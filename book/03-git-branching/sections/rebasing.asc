[[_rebasing]]
=== 使用變基

(((rebasing)))
在 Git 中要把一個分支中整合到另一個分支有兩種主要方式：`merge` 和 `rebase`；
在這一章將會學習到什麼是變基（譯註：變更基準）、如何使用它、為什麼它如此令人驚豔，以及在什麼情況下你不會想用它。

==== 基本變基用法

回顧先前在 <<_basic_merging>> 中的範例，可以看到工作被分隔在二個不同的分支上，並各自做了一些提交。

.簡單的歷史分離
image::images/basic-rebase-1.png[簡單的歷史分離。]

如同我們已經介紹過的，最容易的分支整合方法是 `merge` 命令：
它會把兩個分支最新的快照（`C3` 和 `C4`）以及二者最接近的共同祖先（`C2`）進行三方合併，產生一個新的快照（並提交，譯註：`C5`）。

.使用合併的方式來整合分離的工作歷史
image::images/basic-rebase-2.png[使用合併的方式來整合分離的工作歷史。]

然而，還有另外一種方法：你可以把 `C4` 修改內容的補綴，重新套用到 `C3` 之上，
它在 Git 中被稱為「變基」；
有了 `rebase` 命令，你就可以把一個分支中已經提交的內容在另一個分支上「重演」。(((git commands, rebase)))

像這種例子，可以執行以下命令：

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

它的原理是找到兩個分支（一個是目前分支 `experiment` 準備要變更基準，一個是要被當做新基準的分支 `master`）的共同祖先，然後取得共同祖先到目前分支之間的每一個提交的差異內容，將每個差異內容存成暫存檔，接著將目前分支重置到新基準分支 `master` 所指向的提交，最後逐一地套用每個變更。

.將 `C4` 所引入的的變更內容變基到 `C3`
image::images/basic-rebase-3.png[將 `C4` 所引入的的變更內容變基到 `C3`。]

此時你可以回到 `master` 分支進行快進合併：

[source,console]
----
$ git checkout master
$ git merge experiment
----

.快進 master 分支
image::images/basic-rebase-4.png[快進 master 分支。]

`C4'` 的快照內容和上一個合併例子中的 `C5` 的快照內容是完全一模一樣的；
雖然最後整合的結果沒有任何區別，但變基能產生一個更為簡潔的歷史；
如果你檢視一個變基後的分支日誌，它看起來就像是線性的歷史，仿佛所有工作是依序完成的，儘管它們曾經是在平行的分支裡進行的。

使用變基的目的常常是想要將你的提交能夠乾淨地套用在遠端分支之上——或許這個遠端分支在你想試著貢獻的專案中，但你並不負責維護這個專案；
在這種情況下，你可以先在一個分支裡進行開發，當完成開發時，再將你的分支變基到 `origin/master` 之上，然後向主專案遞送你的補綴檔；
這樣維護者就不需要做任何整合工作——只需要快進，或者乾淨地套用補綴檔。

請注意，無論是透過變基還是合併，最終結果的最後一個提交所指向的快照內容都會是一樣的——唯一不同的是歷史的樣貌：
變基是在新基準的分支上依照原來分支的修改次序重演一遍修改內容，而合併是把二個分支的末端合併在一起。

==== 更多有趣的變基

變基也可以在其它分支上重演，並不一定非得根據分化之前的分支；
以 <<rbdiag_e>> 的歷史為例（譯註：圖示中 `C` 的後綴數字並不代表提交順序，重點在分支圖形），
為了在專案中加入伺服端功能而建立了主題分支 `server`，然後做了一次提交（譯註：`C3`）；
然後從這裡再建立一個 `client` 分支用來加入客戶端功能，並做了一些提交（譯註：`C8` 和 `C9`）；
最後，回到 `server` 分支再多做了一些提交（譯註：`C4` 和 `C10`）。

[[rbdiag_e]]
.從一個主題分支中再分出另一個主題分支的歷史
image::images/interesting-rebase-1.png[從一個主題分支中再分出另一個主題分支的歷史。]

假設你決定在下一個發行版中只想合併客戶端功能到主線中，而伺服端的功能則推遲到進一步測試之後；
你可以使用 `git rebase` 的 `--onto` 選項，它會取出 `client` 的修改內容，然後排除 `server` 分支的共同修改內容，得出 `C8` 和 `C9` 後，再將它們在 `master` 分支上重演：

[source,console]
----
$ git rebase --onto master server client
----

這好比在說：「檢出 `client` 分支，找出 `client` 和 `server` 分支的共同祖先之後的補綴，然後把它們在 `master` 上重演」（譯註：這條命令可以從後面開始往前解讀；另一種更簡潔的解讀：檢出 `client`，差集 `server`，在 `master` 上重演）；
有點複雜，不過結果卻相當酷！

.將一個主題分支從另一個主題分支上變基出去
image::images/interesting-rebase-2.png[將一個主題分支從另一個主題分支上變基出去。]

現在可以快進 `master` 分支了（詳見 <<rbdiag_g>>）：

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.快進 master 分支以納入客戶端分支的修改內容
image::images/interesting-rebase-3.png[快進 master 分支以納入客戶端分支的修改內容。]

假設你決定把 `server` 分支也包含進來，
你可以直接把 `server` 分支變基到 `master`，而不用先檢出 `server` 分支，只要使用 `git rebase [新基準分支] [主題分支]` 命令——它會為你檢出主題分支（此例中的 `server`），然後在新基準分支 `master` 上重演主題分支：

[source,console]
----
$ git rebase master server
----

於是，在 `master` 之上重演了 `server` 的工作，如 <<rbdiag_h>> 所示。

[[rbdiag_h]]
.將 `server` 分支變基到 `master` 分支之上
image::images/interesting-rebase-4.png[將 `server` 分支變基到 `master` 分支之上。]

然後就可以快進新基準分支 `master` 了：

[source,console]
----
$ git checkout master
$ git merge server
----

你可以移除 `client` 和 `server` 分支，因為所有的工作內容都已經被整合了，你也不再需要它們了；這整個過程最終的提交歷史就像 <<rbdiag_i>>：

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.最終提交歷史
image::images/interesting-rebase-5.png[最終提交歷史。]

[[_rebase_peril]]
==== 使用變基的危險

(((rebasing, perils of)))
呃，但是奇妙的變基也並非完美無缺，基本上可以歸結出一條守則：

「不要變基公開在外的提交」

如果你遵循這條金科玉律，就不會出差錯；
否則，人們會仇恨你，你的朋友和家人也會鄙視你。

在進行變基時，其實你放棄了一些現存的提交而創造了一些類似但不太一樣的新提交；
如果你把提交推送出去，並且其他人拉取它們、在這個基礎上工作，而稍後你又用 `git rebase` 重寫了這些提交，再次把它們推送出去；你的同事將不得不重新合併他們的工作，否則當你再次從他們那裡取得內容時，提交歷史就會變得一團糟。

讓我們用一個例子來說明為什麼變基已公開的工作會帶來問題；
假設你從一個中央伺服器克隆，然後在它的基礎上開發，
提交歷史類似下圖所示：

.克隆一個版本庫，以它為基準展開工作
image::images/perils-of-rebasing-1.png[克隆一個版本庫，以它為基準展開工作。]

此時，有人做了其它的工作，其中包含了一個合併提交，並且推送到中央伺服器；
而你獲取並合併這個遠端分支新的工作內容到你的工作中，使得你的提交歷史變成下圖這樣：

.獲取更多的提交，並合併到你的工作之中
image::images/perils-of-rebasing-2.png[.獲取更多的提交，並合併到你的工作之中。]

接下來，那個將合併結果推送上來的人決定改用變基取代原來合併操作，並用 `git push --force` 覆蓋了伺服器上的歷史（譯註：遠端的 master 改指向 `C4'`）；
而之後你從伺服器上獲取新提交後，會得到：

[[_pre_merge_rebase_work]]
.有人推送了變基後的提交，而放棄了你已工作其上的提交
image::images/perils-of-rebasing-3.png[有人推送了變基後的提交，而放棄了你已工作其上的提交。]

現在你們倆都尷尬了！
如果你執行 `git pull`，將會得到一個合併提交（譯註：`C8`），同時包含了那二條歷史，你的版本庫看起來將會是這樣：

[[_merge_rebase_work]]
.你再次合併了相同的工作內容到一個新的合併提交
image::images/perils-of-rebasing-4.png[你再次合併了相同的工作內容到一個新的合併提交。]

如果用 `git log` 查看歷史，會看到有兩個提交（譯註：`C4` 和 `C4'`）擁有相同的作者、日期與訊息，令人費解；
更糟的是，如果你把這樣的歷史再推送到伺服器，會把哪些變基前的提交重新引入到中央伺服器，進一步迷惑其它人；
可以相當確定的是那個開發人員並不想要想將 `C4` 和 `C6` 留在歷史中，那也是為什麼他後來改用變基。

[[_rebase_rebase]]
==== 用變基解決變基

如果你發現你 *真的* 身處如此窘境，Git 還有更神奇的功能或許能幫到你；
如果你在一個基準上展開工作，你的團隊中卻有人強制推送變更而改寫了那個基準，你將挑戰如何找出哪些是你的修改內容，而哪些是被改寫的內容。

這使得 Git 除了計算提交的 SHA-1 校驗碼以外，還計算了這個提交所引入的補綴內容的校驗碼，
這就是所謂的「patch-id」。

如果你從同伴那裡拉取了被改寫的歷史，並變基在新的提交之上，Git 常常能夠成功地找出真正屬於你的提交，並將它們套用在新的分支之上。

舉例說明，在之前的場景中，如果當初在 <<_pre_merge_rebase_work>> 不是使用合併的方式，而是改用 `git rebase teamone/master`，Git 將會：

* 找出哪一些是屬於目前分支的提交（C2、C3、C4、C6、C7）
* 再從中排除合併提交（剩下 C2、C3、C4）
* 再排出已重覆在目的分支中的提交（因為 C4 和 C4' 是一樣的而被排除，只剩下 C2 和 C3）
* 將剩下的提交套用在 `teamone/master` 之上

因此，你不會得到我們在 <<_merge_rebase_work>> 中所看到的，最終結果反而像 <<_rebase_rebase_work>> 中的樣子。

[[_rebase_rebase_work]]
.變基到被強制推送的變基之上。
image::images/perils-of-rebasing-5.png[變基到被強制推送的變基之上。]

注意！這只有在 `C4` 和 `C4'` 的補綴內容完全一致時才會奏效；
否則，變基將無法分辨出它是重覆的，而會加入另一個很像 `C4` 的補綴（但很可能會無法乾淨地被套用，因為類似的修改內容已存在了）。

相對於使用 `git pull`，可以改用 `git pull --rebase` 來簡化這個過程；
或者使用 `git fetch` 加上 `git rebase teamone/master` 手工地操作這種情況。

如果你想在執行 `git pull` 時預設使用 `--rebase` 選項，你可以設定 `pull.rebase` 組態值，類似 `git config --global pull.rebase true`。

如果變基只用來整理被推送前的提交，並且只變基從未被公開的提交，那你就不需要擔心這些事。
如果你變基了那些已推送而公開的提交，而有人可能以那些提交為基準展開新的工作，那麼你可能會倦入令人沮喪的麻煩之中，並遭到隊友的鄙視。

如果你和你的同伴發現變基公開的提交是必要的事情，請確認每個人都知道如何使用 `git pull --rebase` 來試著減輕這過程中所帶來的痛苦。

==== 變基 vs. 合併

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
現在你已經見識過如何操作變基和合併，你或許會想到底哪一種比較好？
在回答這個問題之前，讓我們回過頭來先討論另一個問題：「提交歷史存在的義意為何？」。

其中一個觀點是版本庫的提交歷史應該*忠實地記錄開發過程*；
它是歷史文件，歷史的正確性正是它存在的價值，並且不該被篡改。
從這個角度來說，改變提交歷史是一種褻瀆行為，是在對實際所發生的事進行編撰謊言。
那麼要是造成一團亂糟的合併提交歷史又該怎麼說呢？
那就是它發生的歷程，版本庫應該為後來的人查閱而保留真實歷史。

另一種相反的觀點是提交歷史應該*用一種敍述故事的方來呈現專案開發的過程*；
就像你不會把初稿拿來出書一樣，反而應該像軟體維護手冊那樣需要反覆地仔細修訂。
這個陣營的人會使用 `rebase` 和 `filter-branch` 這一類的工具，以最好方式為未來的讀者呈現更容易閱讀的故事內容。

現在回到原來的問題：合併和變基哪一種比較好？希望你現在能明白它不是那麼容易回答的了；
Git 是一個強大的工具，它允許你對歷史做許多修改動作，但每個團隊和每個專案都有不同的做法和觀點；
而現在你已明瞭這二者是如何運操作的，你可以針對你自己特定的情況來決定哪一種方式才是最好的。

總而言之，想要兩全其美的話，記得「如果是為了整理提交歷史而使用變基，則只變基那些還沒推送而公開的本地提交；千萬不要變基任何已推送出去的提交」。
